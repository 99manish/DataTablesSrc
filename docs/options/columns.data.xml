<?xml version="1.0" encoding="UTF-8" ?>
<dt-option group="columns">
	<name>columns.data</name>
	<summary>Set the data source for the column from the rows data object / array</summary>
	<since>1.10</since>

	<type type="integer">
		<description>
			Treated as an array index for the data source. This is the default that DataTables uses (incrementally increased for each column).
		</description>
	</type>
	<type type="string">
		<description>
			Read an object property from the data source. There are three 'special' options that can be used in the string to alter how DataTables reads the data from the source object:

			* `.` - Dotted Javascript notation. Just as you use a `.` in Javascript to read from nested objects, so to can the options specified in `data`. For example: `browser.version` or `browser.name`. If your object parameter name contains a period, use `\\` to escape it - i.e. `first\\.name`.
			
			* `[]` - Array notation. DataTables can automatically combine data from and array source, joining the data with the characters provided between the two brackets. For example: `name[, ]` would provide a comma-space separated list from the source array. If no characters are provided between the brackets, the original array source is returned.

			* `()` - Function notation. Adding `()` to the end of a parameter will execute a function of the name given. For example: `browser()` for a simple function on the data source, `browser.version()` for a function in a nested property or even `browser().version` to get an object property if the function called returns an object. Note that function notation is recommended for use in `render` rather than `data` as it is much simpler to use as a renderer.
		</description>
	</type>
	<type type="null">
		<description>
			Use the original data source for the row rather than plucking data directly from it. This action has effects on two other initialisation options:
			
			* `dt-init columns.defaultContent` - When null is given as the `data` option and `defaultContent` is specified for the column, the value defined by `defaultContent` will be used for the cell.
			
			* `dt-init columns.render` - When null is used for the `data` option and the `render` option is specified for the column, the whole data source for the row is used for the renderer.
		</description>
	</type>
	<type type="function">
		<signature>data( data, type, row )</signature>
		<parameter type="node" name="cell">
			The `tag TD` node that has been created
		</parameter>
		<parameter type="node" name="cellData">
			The data for the cell
		</parameter>
		<parameter type="node" name="rowData">
			Data source object / array for the whole row
		</parameter>
		<returns>
			The return value from the function is not required when 'set' is the type of call, but otherwise the return is what will be used for the data requested.
		</returns>
		<description>
			The function given will be executed whenever DataTables needs to set or get the data for a cell in the column.
		</description>
		<scope>HTML table element</scope>
	</type>
	<default>
		Takes the index value of the column automatically
	</default>

	<description>
		This property can be used to read data from any data source property, including deeply nested objects / properties. `data` can be given in a number of different ways which effect its behaviour as documented above.

		Note that `data` is a getter and setter option. If you just require formatting of data for output, you will likely want to use `dt-init columns.render` which is simply a getter and thus simpler to use!
	</description>

	<example title="Read table data from objects"><![CDATA[
// JSON structure for each row in this example:
//   {
//      "engine": {value},
//      "browser": {value},
//      "platform": {value},
//      "version": {value},
//      "grade": {value}
//   }
$('#example').dataTable( {
  "ajaxSource": "sources/objects.txt",
  "columns": [
    { "data": "engine" },
    { "data": "browser" },
    { "data": "platform" },
    { "data": "version" },
    { "data": "grade" }
  ]
} );
]]></example>

	<example title="Read information from deeply nested objects"><![CDATA[
// JSON structure for each row:
//   {
//      "engine": {value},
//      "browser": {value},
//      "platform": {
//         "inner": {value}
//      },
//      "details": [
//         {value}, {value}
//      ]
//   }
$('#example').dataTable( {
  "ajaxSource": "sources/deep.txt",
  "columns": [
    { "data": "engine" },
    { "data": "browser" },
    { "data": "platform.inner" },
    { "data": "platform.details.0" },
    { "data": "platform.details.1" }
  ]
} );
]]></example>

	<example title="Using `data` as a function to provide different information for sorting, filtering and display. In this case, currency (price)"><![CDATA[
$('#example').dataTable( {
  "columnDefs": [ {
    "targets": 0,
    "data": function ( source, type, val ) {
      if (type === 'set') {
        source.price = val;
        // Store the computed dislay and filter values for efficiency
        source.price_display = val=="" ? "" : "$"+numberFormat(val);
        source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
        return;
      }
      else if (type === 'display') {
        return source.price_display;
      }
      else if (type === 'filter') {
        return source.price_filter;
      }
      // 'sort', 'type' and undefined all just use the integer
      return source.price;
    }
  } ]
} );
]]></example>

	<example title="Using default content"><![CDATA[
$('#example').dataTable( {
  "columnDefs": [ {
    "targets": [ 0 ],
    "data": null,
    "defaultContent": "Click to edit"
  } ]
} );
]]></example>

	<example title="Using array notation - outputting a list from an array"><![CDATA[
$('#example').dataTable( {
  "columnDefs": [ {
    "targets": [ 0 ],
    "data": "name[, ]"
  } ]
} );
]]></example>

	<related type="option">columns.render</related>
</dt-option>