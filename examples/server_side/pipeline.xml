<?xml version="1.0" encoding="UTF-8" ?>
<dt-example table-type="ajax" order="10">

<css lib="datatables" />
<js lib="jquery" />
<js lib="datatables" />

<title>Pipelining data to reduce Ajax calls for paging</title>
<js><![CDATA[

//
// Pipelining function for DataTables. To be used to the `ajax` option of DataTables
//
$.fn.dataTable.pipeline = function ( opts ) {
	// Configuration options
	var conf = $.extend( {
		pages: 5, // number of pages to cache
		url: ''   // script url
	}, opts );

	// Private variables for storing the cache
	var cacheLower = -1;
	var cacheUpper = null;
	var cacheLastRequest = null;
	var cacheLastJson = null;

	return function ( request, drawCallback, settings ) {
		var ajax          = false;
		var requestStart  = request.start;
		var requestLength = request.length;
		var requestEnd    = requestStart + requestLength;
		
		if ( cacheLower < 0 || requestStart < cacheLower || requestEnd > cacheUpper ) {
			// outside cached data - need to make a request
			ajax = true;
		}
		else if ( JSON.stringify( request.sort )    !== JSON.stringify( cacheLastRequest.sort ) ||
		          JSON.stringify( request.columns ) !== JSON.stringify( cacheLastRequest.columns ) ||
		          JSON.stringify( request.filter )  !== JSON.stringify( cacheLastRequest.filter )
		) {
			// properties changed (sorting, columns, filters)
			ajax = true;
		}
		
		// Store the request for checking next time around
		cacheLastRequest = $.extend( true, {}, request );

		if ( ajax ) {
			// Need data from the server
			if ( requestStart < cacheLower ) {
				requestStart = requestStart - (requestLength*(conf.pages-1));

				if ( requestStart < 0 ) {
					requestStart = 0;
				}
			}
			
			cacheLower = requestStart;
			cacheUpper = requestStart + (requestLength * conf.pages);

			request.start = requestStart;
			request.length = requestLength*conf.pages;

			settings.jqXHR = $.ajax( {
				"url":      conf.url,
				"data":     request,
				"dataType": "json",
				"cache":    false,
				"success":  function ( json ) {
					cacheLastJson = $.extend(true, {}, json);

					if ( cacheLower != requestStart ) {
						json.data.splice( 0, requestStart-cacheLower );
					}
					json.data.splice( requestLength, json.data.length );
					
					drawCallback( json );
				}
			} );
		}
		else {
			json = $.extend( true, {}, cacheLastJson );
			json.draw = request.draw; // Update the echo for each response
			json.data.splice( 0, requestStart-cacheLower );
			json.data.splice( requestLength, json.data.length );

			drawCallback(json);
		}
	}
};


//
// DataTables initialisation
//
$(document).ready(function() {
	$('#example').dataTable( {
		"processing": true,
		"serverSide": true,
		"ajax": $.fn.dataTable.pipeline( {
			url: 'scripts/server_processing.php',
			pages: 5 // number of pages to cache
		} )
	} );
} );

]]></js>

<info><![CDATA[

Sever-side processing can be quite hard on your server, since it makes an Ajax call to the server for every draw request that is made. On sites with a large number of page views, you could potentially end up DDoSing your own server with your own applications!

This example shows one technique to reduce the number of Ajax calls that are made to the server by caching more data than is needed for each draw. This is done by intercepting the Ajax call and routing it through a data cache control; using the data from the cache if available, and making the Ajax request if not. This intercept of the Ajax request is performed by giving the `dt-init ajax` option as a function. This function then performs the logic of deciding if another Ajax call is needed, or if data from the cache can be used.

Keep in mind that this caching is for paging only; the pipeline must be cleared for other interactions such as sorting and filtering since the full data set, when using server-side processing, is only available at the server.

]]></info>

</dt-example>
